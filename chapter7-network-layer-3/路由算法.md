# 网络层-下

## 路由算法

网络层的核心功能就是路由和转发，路由器需要根据『转发表』将到达的数据报转发到某个输出接口上，再进行发送。

在这个过程中起到关键作用的是转发表，而转发表这些信息的得来需要依靠『路由算法』确定去往目的网络的最佳路径。

![路由算法-路由表](https://i.loli.net/2018/10/22/5bcd1e9835e42.png)

如果将路由器、链路的集合分别记作 $N, E$，那么网络层可以抽象成一个图 $G = (N, E)$。图结构在网络领域应用很广泛，常见的还有 P2P 应用（$N$ 是 peers，$E$ 是链路集合）。

![网络层的图抽象](https://i.loli.net/2018/10/22/5bcd1fb95ae38.png)

我们往往用 $c(x, x')$ 表示链路 $(x, x')$ 的『费用』（Costs），即网络传输所需要的开销，它实际上可以是带宽的倒数、拥塞程度等等，它的值越大，网络状况越差。

一条路径 $(x_1, x_2, ..., x_p)$ 的总费用为：

$$
C(x_1, x_2, ..., x_p) = c(x_1, x_2) + c(x_2, x_3) + ... + c(x_{p-1}, x_p)

\tag{1}
$$

我们的路由算法的目的就是求源路由器 $u$ 到目的路由器 $z$ 的最小费用路径。

在网络的发展中，有很多路由算法被提出。

按照配置方式可以分为两类：

+ 静态路由
    + 手工配置
    + 路由更新慢
    + 优先级高
+ 动态路由
    + 自动计算
    + 路由更新快
    + 定期更新，及时响应链路费用或网络拓扑信息

静态路由需要人工管理，优先级较高，但是往往人力有限的情况下，我们会采用动态路由。

对于动态路由算法，按照是否掌握全局信息可以分为两类：

+ 全局信息
    + 所有路由器掌握完整的网络拓扑和链路费用信息
    + 常见的有『链路状态（LS）路由算法』
+ 分散（decentralized）信息
    + 路由器只掌握【物理相连】的邻居及其链路费用
    + 通过邻居间的信息交换、运算迭代可以找到一个到目的路由器的最佳路径
    + 常见的有『距离向量（DV）路由算法』

## 链路状态（LS）路由算法

在链路状态算法中，要求每一个路由器都要构建一个『链路状态分组』，其中包括的信息有与该路由器直接相连的邻居路由器 ID 和该路由器与邻居路由器之间的距离。每个路由器都要将这些信息封装成『链路状态分组』并且广播出去，广播过程类似『泛洪』过程，确保所有路由器可以收到链路状态广播，拥有相同的路由图信息。

每一个路由器都知道所有结点（路由器）的网络拓扑和链路费用之后，可以采用 Dijkstra 算法计算从一结点到所有其他节点的最短路径。

在 $k$ 次迭代之后，得到到达 $k$ 个目的结点的最短路径。

定义如下符号：

+ $c(x, y)$：结点 $x$ 到 $y$ 的链路费用，如果 $x$ 和 $y$ 不直接相连，则 $c(x, y) = \infty$。
+ $D(v)$：从源到目的 $v$ 地当前路径费用值。
+ $p(v)$：沿从源到 $v$ 的当前路径，$v$ 的前序结点。
+ $N'$：已经找到最小费用路径的点的集合。

算法及计算过程如下：

```c
1 初始化:
2 N' = {u}  // 起始结点
3 for 所有结点v
4   if v 毗邻 u
5       then D(v) = c(u,v) 
6   else D(v) = ∞
7
8 Loop
9   找出不在 N’ 中的 w ，满足 D(w) 最小
10  将 w 加入N'
11  更新 w 的所有不在 N’ 中的邻居 v 的 D(v):
12  D(v) = min( D(v), D(w) + c(w,v) )
13  /* 到达v 的新费用或者是原先到达v 的费用，或者是
14  已知的到达w 的最短路径费用加上w 到v 的费用 */
15 until 所有结点在 N’中
```

算法的关键在于第 12 行的迭代过程，我们可以通过一个具体的例子来理解它：

![](https://i.loli.net/2018/10/22/5bcd295762de6.png)

在第 1 步中将 $w$ 确认为 $u$ 的最近结点之后添加到 $N'$，更新了 $u, w$ 连通分量到 $v, y$ 的距离，最后 $N' = \{所有结点\}$ 的时候停止迭代。$u$ 到达每一个点的最短路径都是由图中红色圆圈标出，比如在第 1 步选择 $w$ 作为加入 $N'$ 中的点，是因为

在上面的例子中，结点 $w$ 会产生如下所示的『最短路径树』：

```txt
u---3---w--3---v---4---y---2---z
|
|
+---5---x
```

最终得到的路由转发表就是这样的：

|目的|链路|
|----|---|
|v|(u, w)|
|w|(u, w)|
|x|(u, x)|
|y|(u, w)|
|z|(u, w)|

### LS 算法复杂度

总共 $n$ 个结点，每次迭代需要检测所有不在集合 $N'$ 中的结点 $w$，那么总的比较次数为：

$$
\begin{aligned}
    T &= n + (n - 1) + (n - 2) + ... + 1 \\
    &= \frac{(n+1)n}{2}

\tag{2}
\end{aligned}
$$

我们可以通过使用斐波那契堆来减少比较次数，得到更加少的比较次数 $n\log n$。

### 存在震荡（oscillations）可能

假设链路费用是该链路【承载的通信量】。

假设在初始状态的路由图如下。

![](https://i.loli.net/2018/10/22/5bcd9c7f294d3.png)

B, C, D 分别有 1, e, 1 的数据要路由给 A，此时链路费用发生改变，因此在需要转发新的数据时，重新计算路由表：

![](https://i.loli.net/2018/10/22/5bcd9d9374d3e.png)

在这个新的路由表下开始路由新的数据，新的数据被路由之后链路费用再次发生改变，再次重新计算转发表：

![](https://i.loli.net/2018/10/22/5bcd9e15e3d5b.png)

如此周而复始，可能出现新的路由与旧的路由恰好是反方向，从而使数据在两个路由器之间不断来回转发，在 TTL = 0 时被丢弃。

为了解决这个问题，我们可以对转发表的计算做一些推迟，不是每次转发之后都重新计算转发表。

## 距离向量（Distance Vector）路由算法

距离向量算法是一种动态规划算法，基于 Bellman-Ford 方程：

$$
d_x(y) := 从 x 到 y 的最短路径的费用

\tag{3}
$$

于是有：

$$
d_x(y) = \min_v \{c(x, v) + d_v(y)\}

\tag{4}
$$

也就是说，从 x 到 y 的最短路径的费用是在 x 的所有邻居中取一个邻居 v，使得 x 到邻居 v 的费用与邻居 v 到 y 的费用最小。

一个具体的例子：

![](https://i.loli.net/2018/10/22/5bcda58d5eeb6.png)

上图中 u 只需要知道跟邻居结点 v, x, w 之间的费用，再根据相应的 d 值作和即可。利用得到的值进行动态规划可以取出最佳路线（上图中转发表中对目的地为 z 的转发下一跳将对应于 x）。

### 详细解释

由于最初的 d 值很难直接得到，我们需要先做一个估计，然后逐渐迭代得到一个较为精确的值。

$$
D_x(y) = 从结点 x 到结点 y 的最小费用估计

\tag{5}
$$

每个路由结点 x 都要维护一个距离向量 $\mathrm{\mathbf{D_x}}$：

$$
\mathrm{\mathbf{D_x}} = [D_x(y)|y \in N]

\tag{6}
$$

结点 x 为了应用方程 $(4)$，需要知道到每个邻居 v 的费用 $c(x, v)$，同时也要维护该邻居的距离向量 $\mathrm{\mathbf{D_v}} = [D_v(y)|y \in N]$，这可以直接从邻居 v 处获得，同理 x 也要告知所有邻居它自己的距离向量 $\mathrm{\mathbf{D_x}}$。

核心思想：

+ 每个结点不定时地将其自身的距离向量估计发送给其邻居
+ 当 x 接收到邻居的新的距离向量时，立即根据 B-F 方程更新自身的距离向量估计：
    $$
    D_x(y) \leftarrow \min_v \{c(x, v) + D_v(y)\}, \forall y \in N

    \tag{7}
    $$

通过几次迭代，$D_x(y)$ 将收敛于真实距离 $d_x(y)$。

### 特点

### 异步迭代

引发每次迭代的因素为：

+ 局部链路费用的改变
+ 来自邻居的 DV 更新

### 分布式

每个结点只当距离向量 DV 变化时才通告给邻居：

+ 结点在必要时在通告他们的邻居
+ 他们的邻居进入迭代，如果距离向量发生改变，再通知给邻居的邻居

每个结点的状态机如下：

![](https://i.loli.net/2018/10/22/5bcdac9a9e131.png)

### DV 算法的一个具体例子

![](https://i.loli.net/2018/10/22/5bcdad7989227.png)

对于上图的网络，初始的距离向量很容易得出：

结点 x：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|0|2|7|
|y|$\infty$|$\infty$|$\infty$|
|z|$\infty$|$\infty$|$\infty$|

结点 y：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|$\infty$|$\infty$|$\infty$|
|y|$2$|$0$|$1$|
|z|$\infty$|$\infty$|$\infty$|

结点 z：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|$\infty$|$\infty$|$\infty$|
|y|$\infty$|$\infty$|$\infty$|
|z|$7$|$1$|$0$|

重新计算之后得到下面的距离向量：

结点 x：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x（根据 B-F 方程更新）|0|2|3|
|y（直接从邻居获得）|$2$|$0$|$1$|
|z（直接从邻居获得）|$7$|$1$|$0$|

结点 y：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|$0$|$2$|$7$|
|y|$2$|$0$|$1$|
|z|$7$|$1$|$0$|

结点 z：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|0|2|7|
|y|$2$|$0$|$1$|
|z|$3$|$1$|$0$|

由于只有 $x$ 和 $z$ 的自身距离向量发生了改变，只有他们两才告知所有自己的邻居更新后的距离向量，再进一步迭代：

结点 x：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x（根据 B-F 方程更新）|0|2|3|
|y（直接从邻居获得）|$2$|$0$|$1$|
|z（直接从邻居获得）|$3$|$1$|$0$|

结点 y：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|$0$|$2$|$3$|
|y|$2$|$0$|$1$|
|z|$3$|$1$|$0$|

结点 z：
|$From\setminus To$|x|y|z|
|------------------|-|-|-|
|x|0|2|3|
|y|$2$|$0$|$1$|
|z|$3$|$1$|$0$|

这就达到了正确的距离值（稳定状态）。

在链路费用发生变化时：

+ 结点检测本地链路费用变化
+ 更新路由信息，重新计算距离向量
+ 如果 DV 改变，通告所有邻居

```
t0: y 检测到链路费用改变 ，更新 DV ，通告其邻居
t1: z 收到 y 的 的DV 更新，更新其距离向量表，计算到达 x 的最新最小费用，更新其 DV，并发送给其所有邻居
t2: y 收到 z 的 DV 更新， 更新其距离向量表，重新计算 y 的 DV，未发生改变，不再向 z 发送 DV
【收敛完成】
```

总之，迭代终止的条件就是距离向量不再更新，此时正好为相应距离的精确值。

但是如果距离向量不是减小，而是增大，会怎么样呢？下面来看一个具体的例子。

![](https://i.loli.net/2018/10/22/5bcdb96c98940.png)

对于这样的链路，假设在 $t_0$ 时刻 x 检测到 x 与 y 之间的链路费用变为 60 了，y 发现 x 的距离向量发生改变之后要重新进行计算，由于知道 z 到 x 的距离为 5，那么 y 到 x 的距离应该更新 5 + 1 = 6。y 的距离向量发生改变后通知 z，z 重新计算又将到 x 的距离增加 1，后续流程如下：

![](https://i.loli.net/2018/10/22/5bcdba2d4eec1.png)

直到计数到 z 到 x 的距离为 50 时才会收敛，当 60、50 替换为很大的数时，将会造成问题。

这就意味着：『坏消息（费用增加）传播慢』。这就是『无穷计数』（count to infinity）问题。

有时还可能产生环路问题，结果是双方认为可以以较小的费用到达目的结点，结果真实情况是谁也到不了。

### 毒性逆转

为了解决无穷计数问题，可以采用毒性逆转：

如果一个结点（比如 z）到达某目的（比如 x）的最小费用路径是通过某个邻居（比如 y），则通告给该邻居（y）结点到达该目的的距离为无穷大。示例图如下：

![](https://i.loli.net/2018/10/22/5bcdbd1c1f1c5.png)

### 定义最大度量

为了防止网络不可达时，无限循环计算距离向量，我们可以定义一个最大度量（maximum metric）。比如子网 192.168.1.0/24 突然不可达了，我们定义了最大度量为 15 跳步，用 16 跳步表示 $\infty$，就会出现下图所示的迭代过程直至稳定：

![](https://i.loli.net/2018/10/22/5bcdbef7b3dc4.png)

## 层次路由

相比于前两种算法，层次化路由更像是一种路由策略。

性能问题，大规模网络抽象成图实际是不可行的：

+ 表示所有路由器
+ 扁平网络
+ 规模太大
+ 路由表无法存下
+ 距离向量交换数据量太大，淹没路由

同时要考虑管理自治：

+ 网络自治性
+ 互联网(internet) = 网络之网络(network of networks)

具体的方法为：聚合路由器为一个区域，称为『自治系统』 AS(autonomous systems)。同一 AS（某个 ISP、机构等等）内运行相同的的路由协议，称为『自治系统内部路由协议』（intra-AS routing protocol）。不同的自治系统内的路由器可以运行不同的 AS 内部路由协议。同时自治系统之间通过各个自治系统的『网关路由器』（gateway router）进行交流，这些网关路由器位于 AS 边缘，通过链路连接其他 AS 的网关路由器。

转发表由 AS 内部路由算法与 AS 间路由算法共同配置：

+ AS 内部路由算法设置 AS 内部目的网络路由入口（entries）
+ AS 内部路由算法与 AS 间路由算法共同设置 AS 外部目的路由入口

比如在下面的网络结构中：

![](https://i.loli.net/2018/10/22/5bcdc29c82088.png)

假设 AS1 内某路由器收到一个目的地址在 AS1 之外的数据报,路由器应该将该数据报转发给哪个网关路由器呢?

实际上，AS1 必须学习到哪些目的网络可以通过 AS2 到达，哪些可以通过 AS3 到达，同时将这些网络可达性信息传播给 AS1 内部路由器。这些过程必须要自治系统间路由器的相互配合，属于自治系统间路由任务。

在下图中

![](https://i.loli.net/2018/10/22/5bcdc3dc43577.png)

假设 AS1 学习到（通过 AS 间路由协议）子网 x 可以通
过 AS3（网关 1c）到达，但不能通过 AS2 到达，AS 间路由协议向所有内部路由器传播该可达性信息。

路由器 1d 利用 AS 内部路由信息，确定其到达 1c 的最小费用路径接口 I 并在转发表中增加入口：(x, I)。

在下图中

![](https://i.loli.net/2018/10/22/5bcdc4bf79928.png)

假设 AS1 通过 AS 间路由协议学习到：子网 x 通过 AS3 和 AS2 均可到达。

为了配置转发表，路由器 1d 必须确定应该将去往子网 x 的数据报转发给哪个网关，这个任务也是由 AS 间路由协议完成。可以使用『热土豆路由』：将分组发送给最近的网关路由器。过程如下：

![](https://i.loli.net/2018/10/22/5bcdc5512d14d.png)